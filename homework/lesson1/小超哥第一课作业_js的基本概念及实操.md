# JavaScript 的基本概念
## **一、理解篇**
### **1.1 类比代码执行流程**

银行开户的流程演进就是程序语言一步一步演进的历史：
1. 最早开始的开户流程，主要依赖于用户自身和银行的交互，用户通过发出开户申请，银行负责审查和执行，最终确定是否开户。

> 这和最早的代码执行过程很像：代码向客户端请求一个命令，客户端核对无误后，才能执行。写代码的程序员花大量时间，千方百计的查找到错误，修正错误，才能进行下一步。更有可能的是，好容易通过了开户的资格审查，但是得到的并非正确的结果，就像开户的时候，张三的户挂着李四的名字，这个可是大大的不好了。修正这个难题本身，可能回比能正确的执行更重要。

2. 从用户出发，不仅仅是商业史上的重大演进，更是程序员的福音。通过大厅工作人员的检查校对，柜台办理人员的执行申请，是在编程里把编译器和执行器分开，编译的同时预处理，检查是否代码格式存在问题，执行时，关注内部的逻辑关系，把预处理和执行分开，极大的提高了语言的处理效率。

> 例如编辑性语言的  C 语言，通过编辑器的预处理和执行器的运行，提高了代码的处理效率。

3. 虽然按照两个模式提交代码能提高代码的运行效率，但是预处理和处理器能执行后自动执行，而不是让用户跑完大厅后继续在柜台前排队更能提高效率。

> 例如解释性语言的 JavaScript 做到了一边编辑同时执行，虽然从银行的例子来看，是提高了效率，但是不代表 JavaScript 比起 C 语言百利而无一害。

#### JavaScript 与 C 语言的区别
- C 语言运行起来不需要预处理，会体现为 **运行效率高，开发效率低** ；
- JavaScript 语言运行起来一边处理一遍运行，更符合人类语言，更容易读懂，更容易移植到其他平台，体现为 **开发效率高，执行效率低** 。

### **1.2 运行环境**

运行环境和代码的关系，说简单点，就是购物平台和电商的关系。以淘宝为例，淘宝是电商的平台，电商只有有货物，同时把货物上架到淘宝才能出售，确保货物能出售的买家卖家交流服务、能编辑处理货物的物理服务、以及处理钱款关系的支付服务，构成了交易体系的运行环境。

那么代码就相当于是货物，货物上架到运行环境后，要调用环境中服务来执行这段代码，包括这种货物能否找到以及调用合适的内置服务和第三方服务，是否符合可代码的正确格式，以及最终从输入到执行获得输出的结果。

- **总结一下，运行环境就是能满足代码处理和执行的环境，环境本身由内置服务和第三方的服务支持，以及预处理和执行器构成。**

当然，购物平台不止淘宝一家，所以执行代码的工具在不同环境会有不同的服务和体验，就像在亚马逊开店和在淘宝、京东开店一样，肯定有相似之处，但是也有不一样的服务 —— 关于买卖家的沟通，可能淘宝是我看到最好的，没有之一。

那么同样一串 js 代码，由于不同的需求，被送到浏览器的环境和 Node.js 环境，支持第三方库、内置库的不同，会导致编译的结果会有所不同。



### **1.3 V8 引擎**

 V8 引擎，对初学者的我而言，并非一个很熟悉的概念。

简单检索了一下， V8 指的是效率高的 8 缸发动机， V8 引擎可能也是为了说明这个引擎快吧。 V8 引擎是由于 Google 为了提高编码的效率利用 C ++ 编写的一套提高效率的工具，缺失不产生中间代码、直接编译和执行确实提高了效率，但是提高效率更深层次的内容，我并没有看懂，下面是我检索到的文章，我觉得如果你想深入了解V8 引擎，或者以后我想深入了解它，可以借助这篇文章：
http://blog.csdn.net/horkychen/article/details/7761199

但是，我可以理解 V8 引擎像游戏机，当我按下游戏机的按键时，游戏机内部发生了什么我并不知晓，但是我还能很好的控制遥控游戏中的角色，不是吗？目前，我先要看到结果，学会输入和结果之间的关系已经足够了。

- **总结一下，V8 引擎我可以认为它是个神奇的黑匣子，我不知道黑匣子里面是什么，但是我知道它能同时预处理和执行代码，是运行环境最为核心的组成部分。**

### **1.4 编译器、解析（执行）器**

就我的理解而言，编译器、解析（执行）器其实就是黑匣子 V8 引擎干的事。把它们分开的依据，可能是因为他们的目的不同吧：

- 编译器：分析词法、分析语法、分析语义、优化代码
- 解析（执行）器：解释代码、执行代码

**对于编译器、解析（执行）器，前者负责看代码是否有错误，进行预处理，后者加工。把 V8 引擎看成一个黑匣子般的香肠的加工工具，输入的代码就是肉，输出的是结果是香肠 —— 那么编译器就是肉类的分拣、简单处理、剔除杂质，保证更容易被加工；解析（执行）器就是个干！**

### **1.5～1.6 内置库、第三方库**

理解库的关键在于 —— 为什么需要库？

库是为了能使得代码执行高效而可以被调用的一组程序。其中的一组程序和编译器、解析器一起直接被植入环境，被植入环境的程序叫内置库，不在环境内的叫第三方库。

当环境改变的时候，内置库和第三方库都会改变，就像一个婴儿和一个中年人所生活的环境不同，类似于浏览器的环境和 Node.js 环境的差异，那么它们所需的内置库和第三方库也就不同。

### **1.7 学习 JS 的方向**

工具只是实现方法，而想象力可以把我们带到任何地方。学习 JS 或许是想把想象中和真实构建连接的台阶吧。

学习 JS 之初，先能满足想法的需求，做出来，掌握语言，保证先能实现再说；其次，需要了解服务的类型，用更好的服务服务你的需求；最后能对比服务和技术的差异，用最好的方式实现你的服务。

或许以上是做一个好程序员的需求，但是对我而言，了解 JS 的发展，判断它以后还会怎么发展，以及 JS 的理论还能用在别的其他什么地方，以后未来人和计算机是怎么沟通的，或许是更吸引我深入与它对话的原因吧。

反正未来大部分人的判断是人工智能，那么，如果人类和计算器交流的是未来的趋势，为什么不先假定这个计算器领域使用最广泛的语言 —— JS 开始呢？

## **二、代码篇**

### **2.1 git 基础**

#### GitHub 新建项目指南
1. Fork项目／新建自己的项目
    - New repository
2. 克隆项目到本地 
    - git clone url
3. 第一次改动
4. 查看改动的文件 
    - git status
5. 改动本地提交
    - git add -A
    - git commit -m"改动内容"
6. 推送到远程仓库(远程服务器)
    - git push origin master

#### Fork 项目更新

**命令模式：**

1. 确定同步的本地文件地址
    - 终端 > cd 到自己 fork 后 git clone 的项目
2. 数据源
    - git remote add upstream xxxx
    - “xxxx”代表你需要与之保持同步的数据源，需要键入同步的git项目地址
3. 取上游数据 
    - git checkout master //切换至master分支下
    - git fetch upstream //获取上游数据
4. 数据合并
    - git merge upstream/master//进行主节点和上游节点数据的合并

5. 本地合并后文件上传至 github 服务器上
    - git push origin master

#### 山穷水尽：丢弃所有本地改动和提交，从服务器获得新历史版本

     git fetch origin   
     git reset --hard origin/master
### **2.2 还未熟悉掌握的指令**

#### rm 命令 删除文件或牡蛎

     rm file_name
     rm -rf file_name // 强制删除
